set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR})
string(TOUPPER "${CMAKE_BUILD_TYPE}" BUILD_TYPE)

# Prefer static libraries when possible
set(BUILD_SHARED_LIBS OFF CACHE BOOL "" FORCE)


# == GLFW (3.x) == Upstream: https://github.com/glfw/glfw == License: zlib
set(GLFW_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(GLFW_BUILD_TESTS OFF CACHE BOOL "" FORCE)
add_subdirectory(glfw/)

# == glm == Upstream: https://github.com/g-truc/glm == License: MIT
add_library(glm INTERFACE)
target_include_directories(glm INTERFACE "${CMAKE_CURRENT_SOURCE_DIR}/glm/")

# == Boost (context) == Upstream: https://www.boost.org/ == License: Boost 1.0
#find_package(Boost REQUIRED COMPONENTS context)
#add_library(boost INTERFACE)
#target_include_directories(boost INTERFACE ${BOOST_INCLUDE_DIRS})
#target_link_libraries(boost INTERFACE ${BOOST_LIBRARIES})

# == boost_context_ftl (forked boost::context from FiberTaskingLib)
# == Upstream: https://github.com/RichieSams/FiberTaskingLib
# == License: Apache2 (see file: boost_context_ftl/LICENSE.md)
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/boost_context_ftl")
add_subdirectory(boost_context_ftl/)

# == moodycamel::concurrentqueue
# == Upstream: https://github.com/cameron314/concurrentqueue
# == License: Boost 1.0
add_library(concurrentqueue INTERFACE)
target_include_directories(concurrentqueue INTERFACE "${CMAKE_CURRENT_SOURCE_DIR}/concurrentqueue/")

# == Vulkan (+ vulkan-hpp)
# == Upstream: https://www.khronos.org/vulkan/ [imported via find script]
# == License: Apache2 (see system headers)
find_package(Vulkan REQUIRED)
add_library(vulkan INTERFACE)
target_include_directories(vulkan INTERFACE ${Vulkan_INCLUDE_DIRS})
target_link_libraries(vulkan INTERFACE ${Vulkan_LIBRARIES})

# == flextgl
# == Upstream: https://github.com/mosra/flextgl/
# == License: MIT (see file: flextgl/COPYING)
# ----- NOTE -----
# flextGL is not actually present, its autogenerated code is in-tree. That code
# depends on legacy libGL (found via find script) to implement GL1.1 functions
# and GLFW3 (that is also in-tree) to load all other GL functions.
set(OpenGL_GL_PREFERENCE "LEGACY")
find_package(OpenGL 1.1 REQUIRED)

add_library(flextgl STATIC flextgl/flextGL.c)
target_include_directories(flextgl PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/flextgl/")
target_link_libraries(flextgl PUBLIC ${OPENGL_gl_LIBRARY} glfw)

# == tinyformat
# == Upstream: https://github.com/c42f/tinyformat [in-tree]
# == License: Boost 1.0
add_library(tinyformat INTERFACE)
target_include_directories(tinyformat INTERFACE "${CMAKE_CURRENT_SOURCE_DIR}/tinyformat/")

# == rpmalloc (optional)
# == Upstream: https://github.com/rampantpixels/rpmalloc [in-tree, custom build steps]
# == License: public domain
option(ARES_USE_RPMALLOC "Use rpmalloc instead of the default memory allocator" OFF)
if(ARES_USE_RPMALLOC)
    set(RPMALLOC_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/rpmalloc")

    add_library(rpmalloc STATIC "${RPMALLOC_ROOT}/rpmalloc/rpmalloc.c")
    target_include_directories(rpmalloc PUBLIC "${RPMALLOC_ROOT}/")
    target_compile_definitions(rpmalloc PUBLIC ENABLE_STATISTICS=1)

    if(BUILD_TYPE MATCHES DEBUG)
        # Disable rpmalloc's assertions in Release/RelWithDebInfo
        # Otherwise, NDEBUG would get #undef'd in rpmalloc.c, causing assertions
        # to trigger even in release builds!
        target_compile_definitions(rpmalloc PUBLIC ENABLE_ASSERTS=1)
    endif()
endif()

# == plthook
# == Upstream: https://github.com/kubo/plthook [in-tree, custom build steps]
# == License: BSD 2-clause
if(WIN32)
    set(PLTHOOK_SOURCE_FILE "plthook_win32.c")
    set(PLTHOOK_DEPS
        dbghelp  # for ImageDirectoryEntryToData
    )
elseif(APPLE)
    set(PLTHOOK_SOURCE_FILE "plthook_osx.c")
    set(PLTHOOK_DEPS "")
else()
    set(PLTHOOK_SOURCE_FILE "plthook_elf.c")
    set(PLTHOOK_DEPS "")
endif()

add_library(plthook STATIC "${CMAKE_CURRENT_SOURCE_DIR}/plthook/${PLTHOOK_SOURCE_FILE}")
target_include_directories(plthook PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}")
target_link_libraries(plthook PUBLIC ${PLTHOOK_DEPS})


# == tinygltf
# == Upstream: https://github.com/syoyo/tinygltf [in-tree]
# == License: MIT
add_library(tinygltf STATIC tinygltf.cc)
target_include_directories(tinygltf PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/tinygltf/")


# == Bullet Physics (3.x)
# == Upstream: https://github.com/bulletphysics/bullet3 [imported via find script]
# == License: zlib
find_package(Bullet REQUIRED 3)
add_library(bullet INTERFACE)
target_include_directories(bullet INTERFACE ${BULLET_INCLUDE_DIRS})
target_link_libraries(bullet INTERFACE ${BULLET_LIBRARIES})

# == libuv
# == Upstream: https://github.com/libuv/libuv [imported via find script]
# == License: MIT
find_package(Libuv REQUIRED)
add_library(libuv INTERFACE)
target_include_directories(libuv INTERFACE ${LIBUV_INCLUDE_DIR})
target_link_libraries(libuv INTERFACE ${LIBUV_LIBRARIES})

# == OpenSSL
# == Upstream: https://www.openssl.org [imported via find script[
# == License: OpenSSL
find_package(OpenSSL REQUIRED)
add_library(openssl INTERFACE)
target_include_directories(openssl INTERFACE ${OPENSSL_INCLUDE_DIR})
target_link_libraries(openssl INTERFACE ${OPENSSL_LIBRARIES})

# == zlib
# == Upstream: https://github.com/madler/zlib [in-tree]
# == License: zlib (duh)
add_subdirectory(zlib/)

# == uWebSockets
# == Upstream: https://github.com/uNetworking/uWebSockets [in-tree]
# == License: zlib
# == Requires: libuv, openssl, zlib
add_library(uwebsockets STATIC
    uWebSockets/src/Epoll.cpp
    uWebSockets/src/Extensions.cpp
    uWebSockets/src/Group.cpp
    uWebSockets/src/HTTPSocket.cpp
    uWebSockets/src/Hub.cpp
    uWebSockets/src/Networking.cpp
    uWebSockets/src/Node.cpp
    uWebSockets/src/Socket.cpp
    uWebSockets/src/WebSocket.cpp
)
target_include_directories(uwebsockets PUBLIC
    "${CMAKE_CURRENT_SOURCE_DIR}/uWebSockets/src/"
)
target_link_libraries(uwebsockets PUBLIC
    libuv
    openssl
    zlib
    #ws2_32 - already linked in by libuv
)

# Force uWebSockets to use libuv as backend on all platforms
# Doesn't hurt since `Ares::Core::run()` services libuv's default loop anyways
target_compile_definitions(uwebsockets PUBLIC -DUSE_LIBUV=1)

if(WIN32)
    # `inet_ntop()` is in WinSock2 only from Windows Vista and later; set
    # WINVER=0x501 to require Windows 7 or greater
    # Could be circumvented, see https://memset.wordpress.com/2010/10/09/inet_ntop-for-win32/
    target_compile_definitions(uwebsockets PUBLIC
        -DWINVER=0x601
        -D_WIN32_WINNT=0x601
    )
endif()
